Для передачи сообщений о состоянии устройства используется pipe с именем "device_state".

Use case

Precondition
Несколько серверов используют один и тот же topic для передачи сообщений device state.
Каждый сервер имеет уникальное значение EID.
Абонент может зарегистрироваться на любом из серверов.

Конфигурация kafka.conf:
[producer_device_state]
type=producer
cluster=kafka_cluster

[topic]
type=topic
pipe=device_state
topic=имя_топика
producer=producer_device_state

В такой конфигурации будет использоваться message key, значением которого является
имя устройства (без используемой технологии. Т.е. если полное имя "PJSIP/1234", то
значением ключа будет "1234"). Это гарантирует, что сообщения от одного абонента "1234"
всегда будут попадать в одну и ту же kafka partition. Кроме того, там эти сообщения
сохраняются в порядке их поступления.
См. ответ на вопрос https://stackoverflow.com/questions/29511521/is-key-required-as-part-of-sending-messages-to-kafka

Возможные состояния (свойство "state"):
"UNKNOWN"       Valid, but unknown state
"NOT_INUSE"     Not used
"INUSE"         In use
"BUSY"          Busy
"INVALID"       Invalid - not known to Asterisk
"UNAVAILABLE"   Unavailable (not registered)
"RINGING"       Ring, ring, ring
"RINGINUSE"     Ring and in use
"ONHOLD"        On Hold

Алгоритм обработки сообщений для определения состояния агента

Создаем внутреннюю таблицу agents вида
|agent|eid|state|
где столбец agent содержит только уникальные значения идентификаторов агентов

1. Получить сообщение из топика c reason == "device_state"
2. Если в таблице agents нет записи со значением agent == key (вариант: со значением
payload.name, но его лучше не использовать, т.к. в дальнейшем возможна миграция
абонентов с канала SIP на канал PJSIP или их микс на разных серверах. В этом случае
при одном и том же значении key="1234" в зависимости от способа текущей регистрации
абонента значение payload.name может быть "SIP/1234" или "PJSIP/1234"), то добавляем
в нее строку по этому сообщению и переходим к пункту 1.
3. Если в текущем сообщение значение payload.state является любым, кроме 
"UNKNOWN", "INVALID", "UNAVAILABLE", то в таблице agents заменяем значения столбцов eid и
state на значения eid и payload.state из данного сообщения и переходим к пункту 1.
4. Если в текущем сообщение eid не совпадает со значением eid из соответствующей
строки таблицы, то данное сообщение отбрасываем и переходим к пункту 1.
5. В таблице agents заменяем значения столбцов eid и state на 
значения eid и payload.state из данного сообщения и переходим к пункту 1.

В результате работы алгоритма мы имеем в таблице реальное состояние агента,
независимо от того, на каком из серверов он зарегистрировался и каким образом он
это сделал.

Состояние агента по значению state из сформированной нами таблицы:
"UNKNOWN", "INVALID", "UNAVAILABLE" - агент физически offline
"NOT_INUSE" - агент ничего не делает и готов к работе
"INUSE" - агент обрабатывает вызов, но с ним все-таки можно связаться по второй линии.
"RINGINUSE" - агенту поступил входящий вызов, он еще не ответил, но ему можно послать 
            еще один вызов по второй линии.
"RINGING" - агенту поступил входящий вызов, он еще не ответил, звонить ему сейчас 
            по второй линии бесполезно.
"BUSY" - агент разговаривает, звонить ему по второй линии бесполезно
"ONHOLD" - агент поставил кого-то на удержание
